⭐️ Практика: эксперименты с экзекьюторами

Задание на проверку
Обязательное
Давайте посмотрим, как параметры экзекьютора влияют на пропускную способность системы.

 Основной класс для экспериментов - ReportServiceExecutors

Что там происходит:

Метод getReport формирует отчёт, где комбинирует данные от двух методов - getActiveCustomers и getItems. Первый выполняется в два раза дольше, чем второй.
Оба метода выполняются в отдельных потоках через экзекьютор. С ним мы и будем проводить эксперименты.

Класс LoadGenerator эмулирует два вида нагрузки:

sleep - поток переводится в состояние WAITING. Это аналог блокирующего вызова - запроса в БД или HTTP вызова в другой сервис

compute - вычислительная работа, поток находится в состоянии RUNNABLE

Класс ReportServiceTests представляет аналог нагрузочного теста. Его не нужно менять, только запускать!

Задание:

Напишите число ядер в вашем процессоре. Если у него есть hyper-threading, то отметьте этот факт.
    8 + hyper-threading

Выключите браузер или другие программы, которые занимают процессор и могут исказить результаты экспериментов



Изучите работу с блокирующей нагрузкой:

     Поставьте в LoadGenerator метод sleep:

public static void work() {
     sleep();
     // compute();
}
Поменяйте экзекьютор в классе ReportServiceExecutors

Запустите тест ReportServiceTests и запишите полученное время

Попробуйте разные виды и параметры в ReportServiceExecutors , запишите время выполнения теста при разных вариантах

Например, если у вас 8 ядер, для fixed экзекьютора можно попробовать значения 4, 8, 16, 24, 32. Тогда будет хорошо видна связь между количеством ядер и результатом.

Не забывайте и про другие экзекьюторы - single, fixed, cached

Сведите данные в общую таблицу для удобства анализа

Проанализируйте результаты:
- Что происходит с временем выполнения при увеличении количества потоков?
- Почему так получается? Как процессор работает с такими задачами?
- Определите зависимости между типом задачи, числом ядер, количеством задач и временем выполнения



Изучите работу с вычислительной нагрузкой

 Поставьте в LoadGenerator метод compute:

public static void work() {
     // sleep();
     compute();
}
Поменяйте экзекьютор в классе ReportServiceExecutors

Запустите тест ReportServiceTests и запишите полученное время

Попробуйте разные виды и параметры в ReportServiceExecutors , запишите время выполнения теста при разных вариантах

Не забывайте и про другие экзекьюторы - single, fixed, cached

Сведите данные в общую таблицу для удобства анализа

Проанализируйте результаты:
- Что происходит с временем выполнения при увеличении количества потоков?
- Почему так получается? Как процессор работает с такими задачами?
- Определите зависимости между типом задачи, числом ядер, количеством задач и временем выполнения



Какие рекомендации по экзекьюторам можно вывести из полученных результатов для разных типов задач?
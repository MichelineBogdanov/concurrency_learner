⭐️ Практика: экспериментируем с экзекьютором в CompletableFuture

Задание на проверку
Обязательное
Давайте посмотрим, как параметры экзекьютора в CF влияют на пропускную способность системы. 

Основной класс для экспериментов - ReportServiceCF. На всякий случай напомню:

Метод getReport формирует отчёт, где он комбинирует данные от двух методов - getActiveCustomers и getItems. Первый выполняется в два раза дольше, чем второй. Оба метода выполняются в отдельных потоках через supplyASync. В него можно передать свой экзекьютор.

Класс LoadGenerator эмулирует два вида нагрузки:

sleep - поток переводится в состояние WAITING. Аналог блокирующего вызова - запроса в БД или HTTP вызова в другой сервис

compute - вычислительная работа, поток находится в состоянии RUNNABLE

Класс ReportServiceTests представляет аналог нагрузочного теста. Тест не нужно менять, только запускать.

Задание:

Напишите число ядер вашего компьютера

В тесте ReportServiceTests закомментируйте строку 13 и 15 и раскомментируйте 14. Чтобы получилось так:

//  private ReportServiceExecutors reportService = new ReportServiceExecutors();
    private ReportServiceCF reportService = new ReportServiceCF();
//  private ReportServiceVirtual reportService = new ReportServiceVirtual();
Выключите браузер или другие программы, которые занимают процессор и могут исказить результаты экспериментов

Изучите работу с блокирующей нагрузкой:

Поставьте в LoadGenerator метод sleep:

public static void work() {    
     sleep();
     // compute(); 
}
Поменяйте экзекьютор в классе ReportServiceCF

Запустите тест ReportServiceTests и запишите полученное время

Попробуйте разные виды и параметры в ReportServiceCF, запишите время выполнения теста при разных вариантах

Не забывайте и про другие экзекьюторы - single, fixed, cached, а также про экзекьютор по умолчанию - ForkJoinPool.commonPool()

Сведите данные в общую таблицу для удобства анализа

Проанализируйте результаты:
- Что происходит с временем выполнения при увеличении количества потоков?

- Почему так получается? Как процессор работает с такими задачами?

- Определите зависимости между типом задачи, числом ядер, количеством задач и временем выполнения

- Подходит ли экзекьютор по умолчанию для таких задач?



Изучите работу с вычислительной нагрузкой

Поставьте в LoadGenerator метод compute :

public static void work() {    
     // sleep();
     compute(); 
}
Поменяйте экзекьютор в классе ReportServiceCF

Запустите тест ReportServiceTests и запишите полученное время

Попробуйте разные виды и параметры в ReportServiceCF, запишите время выполнения теста при разных вариантах

Не забывайте и про другие экзекьюторы - single, fixed, cached, а также про экзекьютор по умолчанию - ForkJoinPool.commonPool()

Сведите данные в общую таблицу для удобства анализа

Проанализируйте результаты:
- Что происходит с временем выполнения при увеличении количества потоков?

- Почему так получается? Как процессор работает с такими задачами?

- Определите зависимости между типом задачи, числом ядер, количеством задач и временем выполнения

- Подходит ли экзекьютор по умолчанию для таких задач?